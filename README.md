# Eurica. Test task

## Task 1.1

Создать графическое приложение с использование библиотека Qt, содержащее две пустые формы, содержащие кнопку строго по центру:  
- первая форма – главное окно. При нажатии на кнопку открывается вторая форма.  
- вторая форма – диалог. При нажатии на кнопку создается текстовый файл, содержащий строку текста «Миру мир!» и завершается работа приложения.

Для сборки из папки __test_task__ достаточно написать __make build__ и сборка будет осуществляться при помощи Makefile в директорию __app__, из которой можно будет запустить приложение (___test_task___).  
команда __make clean__ удаляет директорию __app__.

## Task 1.2

Что происходит при вызове виртуальной функции в конструкторе базового класса?

- При вызове виртуальной функции в конструкторе базового класса происходит раннее связывание. При этом вызов функции определяется на этапе компиляции, а не на этапе выполнения.  
Когда вызывается виртуальная функция в конструкторе базового класса, она будет разрешена исходя из типа базового класса, а не производного класса, который фактически создается. Это происходит потому, что во время выполнения объект производного класса еще не создан полностью, и информация о его типе недоступна до завершения конструктора базового класса.

## Task 1.3

В чем разница между struct и class?

- Разница заключается в доступе к членам класса. По умолчанию в class поля и методы являются приватными (__private__). В struct же наоборот, могут быть свободно доступны извне класса (__public__).

## Task 1.4

В чем отличие malloc от new?

- Оба - способы выделения динамической памяти.  
- __malloc__:  
используется для выделения блока памяти заданного размера в байтах в Си и возвращает указатель на начало выделенной памяти типа __void *__. Также при выделении памяти при помощи __malloc__ требуется явное приведение типа указателя к нужному типу данных. Для освобождения памяти использует __free()__  
- __new__:  
используется в С++ для выделения памяти под объекты и вызывает их конструкторы для инициализации. При этом возвращает указатель на созданный объект. Для освобождения памяти использует __delete/delete[]__

## Task 1.5

В чем различия между __delete__ и __delete[]__?

- Используется для единичных объектов, выделенных с помощью __new__
- Используется для массивов объектов, выделенных с помощью __new[]__. Он вызывает деструкторы для каждого элемента массива.  

## Task 1.6

В чем отличие std::list<T> от std::vector<T>?

- __std::list<T>__ - это двусвязный список, где элементы связанны друг с другом с помощью указателей.  
Вставка и удаление элементов в середине списка является очень эффективной операцией (O(1)), так как требует только изменения указателей.  
Однако доступ к элементам списка по индексу происходит за линейное время (O(n)), так как нужно пройти по всему списку, начиная с его начала или конца.  
Нет возможности прямого доступа по индексу.  
- __std::vector<T>__ - это динамический массив, где элементы хранятся в непрерывной области памяти.  
Вставка и удаление элементов в середине вектора может быть затратной операцией (O(n)), так как требует перемещения элементов внутри массива.  
Доступ к элементам вектора по индексу наоборот является очень эффективной операцией (O(1)), так как элементы хранятся в непрерывной области памяти.  
Поддерживает прямой доступ к элементам по индексу.  

## Task 1.7

Для чего нужен тип std::auto_ptr<T>?

- Умный указатель для автоматического управления памятью. Однако, с C++11 этот тип стал устаревшим и с C++17 полностью удален из стандарта.

## Task 1.8

QString a = “Вася”; QString b; b = a; Происходит ли копирование данных?  

- Да, данные из QString a скопируются в QString b.  
Будут созданны свои собственные независимые строки. (QString - неизменяемый тип данных)

## Task 1.9

const char* a = “Вася”; QString b; b = a; Происходит ли копирование данных? Можно ли так вообще делать и почему?

- Да, данные тоже копируются, но делать так не стоит, так как не __const char*__ не то же самое, что и объект __QString__ из Qt.  
Лучше использовать конструктор:  
const char* a = "Вася";
QString b(a); // Создание QString из const char* с копированием данных

## Task 1.10

```QStringList list;  
list << “Вася” << “Петя” << “Коля”;  
QList <const char*> clist;  
QString str;  
  
foreach (str, list) {  
  const char* tmp = str.toLocal8Bit().constData();  
  clist.push_back(tmp);  
}
```

- Код создает массив указателей на const char*, но не освобождает память, на которую указывают эти указатели.  
- При вызове функции func_work_with_const_char_list(clist); необходимо убедиться, что память, на которую указывают элементы списка clist, будет корректно освобождена после использования.
- Возможны проблемы с кодировкой при использовании __toLocal8Bit()__
- Возвращаемый указатель constData() является временным и может стать недействительным после выхода из этой области видимости, это может вызвать ошибки если, изначальный объект QString из которого идет преобразование уничтожится.

## Task 1.11

Чем отличается процесс от потока? Какие вы знаете методы синхронизации потоков? Что такое thread safe класс?

1. __Процесс__ - это экземпляр выполняющейся программы. Каждый процесс имеет свою собственную память и ресурсы. Процессы могут работать независимо друг от друга и изолированы друг от друга. Каждый процесс имеет свой собственный адресное пространство, что делает его недоступным для прямого доступа к памяти другого процесса.  
__Поток__ - это единица исполнения внутри процесса. Потоки совместно используют ресурсы и адресное пространство процесса. Они работают в рамках одного процесса и могут обмениваться данными напрямую. Потоки позволяют параллельное выполнение задач.

2. Методы синхронизации потоков:

  - Мьютексы (Mutex) - это объект синхронизации, который обеспечивает эксклюзивный доступ к ресурсам. Он предотвращает несколько потоков из одновременного доступа к разделяемым данным.  
  - Семафоры (Semaphore) - это счетчик, который управляет доступом к ограниченному количеству ресурсов. Он позволяет ограничить число потоков, имеющих доступ к определенному ресурсу.  
  - Условные переменные (Condition Variables) - используются для ожидания определенного условия, которое может быть изменено другим потоком. Они позволяют потокам эффективно ожидать событий и сигналов от других потоков.  
  - Атомарные операции (Atomic Operations) - обеспечивают доступ к общей памяти без необходимости блокировки. Они гарантируют, что операции выполняются целиком и не могут быть прерваны другими потоками.  

3. Thread-safe класс - это класс, который может безопасно использоваться из нескольких потоков одновременно без возникновения проблем синхронизации. Это означает, что при доступе к методам и данным такого класса из разных потоков, результаты не приведут к неопределенному поведению.

## Task 1.12

Что такое сложность алгоритма и в чем она измеряется? Оцените сложность операции вставки и поиска для следующих типов контейнеров, почему она именно такая:  
std::vector  
std::list  
std::map  
сортированный std::list  
сортированный std::vector  

- Сложность алгоритма позволяет оценить, насколько эффективно работает алгоритм при увеличении объема данных. Обычно сложность измеряется в "О-большое" (Big O) нотации.  

Оценка сложности операции вставки и поиска для различных контейнеров:  

__std::vector__  

- Вставка (в конец): O(1) - константное время, так как добавление элемента в конец вектора выполняется за постоянное время, за исключением случаев, когда требуется расширить вектор (в таком случае может потребоваться перераспределение памяти с линейным временем).
- Поиск: O(n) - линейное время, так как поиск элемента может потребовать перебора всех элементов в худшем случае.

__std::list__  

- Вставка: O(1) - константное время, вставка элемента в двусвязный список происходит за постоянное время, так как не требуется перемещения элементов в памяти.
- Поиск: O(n) - линейное время, поиск элемента потребует прохода по всему списку в худшем случае.  

__std::map__  

- Вставка: O(log n) - логарифмическое время, так как элементы в map хранятся в отсортированном порядке по ключу, и вставка нового элемента потребует выполнения бинарного поиска для нахождения правильной позиции.
- Поиск: O(log n) - логарифмическое время, аналогично вставке, поиск элемента потребует выполнения бинарного поиска.  

__Сортированный std::list__  

- Вставка: O(n) - линейное время, так как вставка нового элемента в сортированный список потребует прохода по всем элементам для нахождения правильной позиции.
- Поиск: O(n) - линейное время, поиск элемента потребует прохода по всем элементам в худшем случае.

__Сортированный std::vector__

- Вставка: O(n) - линейное время, так как вставка нового элемента в отсортированный вектор потребует прохода по всем элементам для нахождения правильной позиции и сдвига всех элементов справа от вставляемого.
- Поиск: O(log n) - логарифмическое время, так как в отсортированном векторе можно использовать бинарный поиск для нахождения элемента.

## Task 1.13

Напишите запрос SQL, который выведет родителей, имеющих не более 2 иждивенцев. 

```
SELECT p.id, p.name
FROM Родители p
LEFT JOIN (
    SELECT parent_id, COUNT(*) as children_count
    FROM Дети
    GROUP BY parent_id
) c ON p.id = c.parent_id
WHERE c.children_count <= 2 OR c.children_count IS NULL;
```

## Task 1.14

```
QString str = “Вася”;
int len = strlen(str.toLocal8Bit().data());
```
Какое значение получит переменная len?

- Она будет равна __8__. Так как __toLocal8Bit__ переводит все в локальную кодировку (UTF-8), а дальше __strlen()__ считает количество байт до первого __\0__ символа. Но __strlen()__ не учитывает символы представляемые несколькими байтами, поэтому такой подсчет может быть некорректным.